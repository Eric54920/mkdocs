---
comments: true
---

设计模式（Design Patterns）是一套被反复使用的、代码设计中被多次验证的、程序员在软件开发过程中面临的、普遍存在的问题的解决方案。设计模式不是代码，而是一些被广泛接受的最佳实践。这些模式通常被分类为三大类：创建型模式、结构型模式和行为型模式。下面是每种类型的主要设计模式的简要介绍：

### 创建型模式

**单例模式（Singleton Pattern）**
   
   - 确保一个类只有一个实例，并提供一个全局访问点。
   - 例如：数据库连接对象。

**工厂方法模式（Factory Method Pattern）**
   
   - 定义一个创建对象的接口，但让子类决定实例化哪一个类。
   - 例如：不同类型的日志记录器（文件日志、数据库日志等）。

**抽象工厂模式（Abstract Factory Pattern）**
   
   - 提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们的具体类。
   - 例如：跨平台UI工具包。

**建造者模式（Builder Pattern）**
   
   - 将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。
   - 例如：构建一个复杂的文档对象（PDF、HTML等）。

**原型模式（Prototype Pattern）**
   
   - 通过复制现有实例来创建新对象，而不是通过类构造器。
   - 例如：复制一个复杂的对象以提高性能。

### 结构型模式

**适配器模式（Adapter Pattern）**
   
   - 将一个类的接口转换成客户希望的另一个接口，使原本由于接口不兼容而不能一起工作的那些类可以一起工作。
   - 例如：将旧系统的接口适配到新系统。

**桥接模式（Bridge Pattern）**
   
   - 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
   - 例如：图形形状和颜色的独立变化。

**组合模式（Composite Pattern）**
   
   - 使得客户可以以一致的方式处理单个对象和对象组合。
   - 例如：文件系统的目录和文件结构。

**装饰模式（Decorator Pattern）**
   
   - 动态地给对象添加一些额外的职责。
   - 例如：为一个图形对象添加边框或阴影。

**外观模式（Facade Pattern）**
   
   - 为子系统中的一组接口提供一个一致的界面。
   - 例如：简化复杂API的使用。

**享元模式（Flyweight Pattern）**
   
   - 运用共享技术有效地支持大量细粒度的对象。
   - 例如：在文本编辑器中共享字符对象。

**代理模式（Proxy Pattern）**
   
   - 为其他对象提供一种代理以控制对这个对象的访问。
   - 例如：远程代理、虚代理和保护代理。

### 行为型模式

**责任链模式（Chain of Responsibility Pattern）**
   
   - 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合。
   - 例如：事件处理系统。

**命令模式（Command Pattern）**
   
   - 将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。
   - 例如：菜单操作、撤销操作。

**解释器模式（Interpreter Pattern）**
   
   - 给定一种语言，定义它的文法的一种表示，并定义一个解释器来处理这种文法。
   - 例如：正则表达式处理。

**迭代器模式（Iterator Pattern）**
   
   - 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
   - 例如：遍历集合对象。

**中介者模式（Mediator Pattern）**
   
   - 用一个中介对象来封装一系列对象的交互。
   - 例如：聊天室中的消息传递。

**备忘录模式（Memento Pattern）**
   
   - 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
   - 例如：撤销操作的实现。

**观察者模式（Observer Pattern）**
   
   - 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
   - 例如：发布-订阅模式。

**状态模式（State Pattern）**
   
   - 允许对象在内部状态改变时改变它的行为。
   - 例如：文档编辑器中的不同状态。

**策略模式（Strategy Pattern）**
   
   - 定义一系列算法，把它们一个个封装起来，并且使它们可以互换。
   - 例如：不同的排序算法。

**模板方法模式（Template Method Pattern）**
   
   - 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
   - 例如：数据处理的不同步骤。

**访问者模式（Visitor Pattern）**
   
   - 封装作用于某种数据结构中的各元素的操作，使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
   - 例如：对象结构的不同操作。

这些设计模式提供了处理常见设计问题的解决方案，能够使代码更加可维护、可扩展和易于理解。